{"componentChunkName":"component---src-templates-post-template-js","path":"/garbage-collection-algorithms/","result":{"data":{"post":{"id":"08c58d29-0d89-541a-9b88-4555c9df0776","html":"<p>Garbage collection has been the subject of much academic research . In particular, the volume of new techniques with various claimed properties is high enough that it is tempting to coin the phrase <a href=\"http://en.wikipedia.org/wiki/Another\">YAGA (Yet Another GC Algorithm)</a>. For a pointer to many of these articles, see <a href=\"http://www.cs.kent.ac.uk/people/staff/rej/gcbib/gcbibP.html\">Richard Jones’ garbage collection bibliography.</a></p>\n<h2>Garbage collection algorithms</h2>\n<p>Despite the large number of variants, most garbage collection algorithms fall into a few simple categories.</p>\n<h2>Reference counting</h2>\n<p>Yes, reference counting is a form of garbage collection. It’s sometimes seen as an alternative to garbage collection, and sometimes even as a morally superior alternative to garbage collection, but really, it’s just a type of garbage collection algorithm.</p>\n<p>Reference counting garbage collectors track the number of references to each object. Often the count is maintained in and by the object itself. When a new reference to an object is added, the reference count is incremented. When a reference is removed, the count is decremented. When the count reaches zero, the object is destroyed and the memory released. Reference counting fails when objects reference one another in a cycle. In these cases each object will be seen to be referenced and will never be freed, even if nothing references the cyclic structure.</p>\n<p>Reference counting is unable to deal with cycles unless augmented with occasional invocations of another form of garbage collection. Reference counting has a number of other disadvantages, mostly to do with performance and bounding of work, and so it is rarely used in modern garbage collection systems. However, smart pointers in C++, while not traditionally considered a form of garbage collection, do make use of reference counting. Ad hoc garbage collectors introduced to manage object reachability in complex environments also tend to use reference counting since it is easily implemented in a hostile environment.</p>\n<h2>Tracing collectors</h2>\n<p>Most garbage collectors perform some sort of tracing to determine object liveness. Tracing does not have the same problem with collecting cycles as reference counting does. However, tracing collectors are more sensitive to changes in the object graph and usually require the suspension of the application threads or close monitoring of application activity to ensure correctness.</p>\n<h3>Mark-sweep</h3>\n<p>Mark-sweep collectors collect in two phases. In the first phase, all reachable objects are traced, begining from a set of roots. The roots are all objects which are guaranteed reachable, including objects referenced from the stack and static variables. Every object directly or indirectly reachable from a root is marked. Objects which do not end up marked are unreachable and therefore cannot be used again by the application, so they may safely be freed.</p>\n<p>In the second phase of a mark-sweep collection, all unmarked objects are added to a free-list. Contiguous areas of free memory are merged on the free list.</p>\n<h3>Mark-compact collectors</h3>\n<p>Mark-compact mark live objects using identical techniques to those used by mark-sweep collectors. However, mark-compact collectors do not use a free list. Instead, in the second phase all reachable objects are moved so that they are stored as compactly as possible. New allocation is then performed from the empty area of the heap.</p>\n<p>Many collectors hybridise these two approaches, combining frequent sweeping with occasional compaction.</p>\n<h3>Copying collectors</h3>\n<p>Copying collectors divide the heap into two areas, a to-space and from-space. All objects are allocated in the to-space. When the new space is full, a collection is performed and the spaces are swapped. All reachable objects in the to-space are copied to the from-space, which is declared the new to-space. New allocation is then performed in the new to-space.</p>\n<p>Copying collectors have a number of advantages over marking collectors.\nBecause copying is done in the same phase as tracing, it is not necessary to maintain a space-consuming list of which objects have been marked. Because no sweep is performed, the cost of the collection is proportional only to the amount of live data.</p>\n<p>If most objects are unreachable, a copying collecton can be very efficient. The corollary is that if most objects remain reachable, or if some very large objects remain reachable, the collection will be woefully inefficient, because a large amount of memory will need to be copied every collection.</p>\n<p>Copying collectors also keep the heap very compact, and this can boost allocation and application performance. However, because a completely empty from-space must be maintained at all times, copying collectors are not space-efficient. Modern collectors tend to estimate an object death-rate and maintain less than half the heap for the from-space accordingly. Copying collectors are also known as semispace collectors.</p>\n<p>For a good overview of how this relates to the IBM JVM’s garbage collection, see Mattias Persson’s <a href=\"https://web.archive.org/web/20200616174904/http://www.ibm.com/developerworks/java/library/j-ibmjava2/\">developerWorks article</a>.</p>","excerpt":"Garbage collection has been the subject of much academic research . In particular, the volume of new techniques with various claimed…","fields":{"title":"Garbage collection algorithms","slug":"/garbage-collection-algorithms/","prefix":"2008-10-07","shortDate":"10-07","category":"java","author":"holly cummins","displayCategory":"java","geography":null,"video":null,"slides":null,"oembeds":null,"cover":{"childImageSharp":{"resize":{"src":"/static/0eee2db2a14bb0f8a1c3584f63bd580c/9dc27/pawel-czerwinski-RkIsyD_AVvc-unsplash.jpg"}}}},"frontmatter":{"type":"blog","event":null,"keynote":null,"code":null,"resources":null}},"authornote":{"id":"77e0dd69-1df1-59df-9a8e-f3f29c267627","html":"<p><strong>Holly Cummins</strong>. Holly Cummins is a Senior Principal Software Engineer at Red Hat, in the Quarkus Team. She is a\nkeynote speaker, author, and bad illustrator.</p>"}},"pageContext":{"slug":"/garbage-collection-algorithms/","prev":{"id":"7cde78ed-ce4d-56f9-9e79-2723ea8beafc","fields":{"slug":"/garbage-collection-myths/","prefix":"2008-10-05","draft":null,"source":"posts","category":"java"},"frontmatter":{"title":"Garbage collection myths","url":null,"type":"blog"}},"next":{"id":"ad0588bb-f9fb-5564-94e1-b6de57aa50e3","fields":{"slug":"/garbage-collection-flavours/","prefix":"2008-10-08","draft":null,"source":"posts","category":"java"},"frontmatter":{"title":"Garbage collection flavours","url":null,"type":"blog"}},"source":"posts"}},"staticQueryHashes":["1862184931","421231837","835725211"]}