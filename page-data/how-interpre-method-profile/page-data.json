{"componentChunkName":"component---src-templates-post-template-js","path":"/how-interpre-method-profile/","result":{"data":{"post":{"id":"47a04663-4ce0-571b-bf86-785d655d63d1","html":"<p>In a <a href=\"/how-do-you-solve-performance-problem/\">previous post</a>, I described the general methodology I use to diagnose performance problems.</p>\n<p>Once an application has been identified as CPU-bound, either by using the <a href=\"https://www.ibm.com/support/pages/java-health-center-client-low-overhead-monitoring-tool\">Health Center</a> or CPU monitoring, the next step is to figure out <em>what</em> is eating CPU. In a Java application, this will usually be Java code, but it could be native code. Profiling native code usually requires platform specific tools; on linux, I use <a href=\"http://perfinsp.sourceforge.net/tprof.html\">tprof</a>. Profiling Java code is a lot easier, and is more likely to yield big performance improvements, so I usually start with a Java profile and only profile native code if I didn’t get anywhere with the Java profile. For Java profiling, I use the Health Center. It’s got a few advantages, one of which is that there’s no bytecode instrumentation needed, there’s no need to specify only a few packages to profile, and the overhead is very low, so it won’t affect the performance characteristics of what you’re trying to profile.</p>\n<p>So what does a method profile tell you? Simply put, it tells you what your application is spending its time doing. More precisely, it tells you what code your application is spending its time running - it doesn’t tell you when your application is waiting on a lock instead of running your code, and it doesn’t tell you when the JVM is collecting garbage instead of running your code. Assuming locking and GC aren’t the cause of the performance problem (see <a href=\"/how-do-you-solve-performance-problem/\">triaging a performance problem</a>), the method profile will give you the information you need to make your application go faster.</p>\n<p>The application is doing too much work, and that’s slowing it down. Your aim in performance tuning is to make the application do less work. There are lots of ways to make code more efficient. Sometimes people start performance tuning by code inspection - they read through the code base looking for obvious inefficiencies. I’ve done this myself lots of times, but it’s not a particularly efficient technique. Say I find a method which is pretty carelessly implemented, and I double its speed with a bit of refactoring. Then I triumphantly re-run my application, only to discover nothing’s changed. What’s going on? The problem is that a big performance improvement on a method which is rarely called isn’t going to change much of anything. For example, if I double the speed of a method which uses 0.5% of my CPU time, I’ve sped my application up by an imperceptible 0.25%. If, on the other hand, I shave 10% of the time of a method which is using 20% of my CPU, my application will go 2% faster. So the first rule of performance tuning is to optimise the methods at the top of the profile and ignore the ones near the bottom.</p>\n<p>This is example from a method profiler, in this case the one in the Health Center. One method is clearly using more CPU than the rest, and so it’s coloured red. In this case, 60% of the time the JVM checked what the application was doing, it was executing the FireworkParticle.animate() method. This is what’s shown by the left-hand ‘Self’ column. The ‘Tree’ column on the right shows how much time the application spent in both the animate() method and its descendants. Some profilers call this column ‘descendants’ instead. Usually the Self figures are more useful for optimising an application.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c3a3cc100b0382e408eadce36e40709e/e17e5/healthcenterprofile.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVQoz5WSy47UMBBF8/9r+AX4BFghIYFAAol50Om8bMdxXrYzA9159awOsnvQ7JBYnNxKxb4plyt5/fYHr95859tNjlSaSv4/QjVIbShFTVJWJUrXNK3BWov3HvcX56Ja5/7JMI5o3dAYQ3JID0gl6foO3WhM19J1LU1naIaexjRYN2KdZYz6wmivedMa8iInLwqS9JiilKJ3ltuPH1Bfv+DPJw6fP5G+f0daFmTZkSzPKMoiEjYGg6K4vte6jkWEwhKtdfzLuq0MzvB02dkuO4NWPCqBbg1CVHFxoBJVNPCTu+Idp9Nvtm2Np0nCw0+eeZnxj55tX5mXM9OvB5annb7vabs2EtoSCHH/HPfD9fsw9mR5ThL6FpofTKy37PvGssw475jnM1JKwsUJKahrFVUIEQ2ds5FwwmnyVEIEwzomlnVmevDsl411nfHeMs8nhKwoyjzSDx3DMyHu+lC5wXnLspzjpSZCaWRtkHVDKdTzbNVxprJCcHufcvczjXpzd4j6wiHm7g9H0qwkzQr+AKfBkNhvWYSSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"healthcenterprofile\"\n        title=\"healthcenterprofile\"\n        src=\"/static/c3a3cc100b0382e408eadce36e40709e/e17e5/healthcenterprofile.png\"\n        srcset=\"/static/c3a3cc100b0382e408eadce36e40709e/772e8/healthcenterprofile.png 200w,\n/static/c3a3cc100b0382e408eadce36e40709e/e17e5/healthcenterprofile.png 400w\"\n        sizes=\"(max-width: 400px) 100vw, 400px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>What makes a method appear near the top of a method profile? It’s taking up a lot of CPU time, but why? There are two reasons; either the method is being called too often, or the method is doing too much work when it’s called. Sometimes it happens that a method really is doing the right amount of work the right number of times, but this is usually only the case after a fair amount of work. In their natural state, most programs can - and should - contain inefficiencies. (Remember that <a href=\"https://web.archive.org/web/20120321090428/http://fresh.homeunix.net/~luke/misc/knuth-turingaward.pdf\">premature optimisation is the root of all evil</a>.)</p>\n<p>Some profilers can distinguish between a method which is called several times, and one which is called once and then spends a long time executing, but many cannot. The reason is that some profilers operate by <em>tracing</em> - that is, recording every entry and exit of a method. This gives very precise information, but usually carries a fairly heavy performance cost. The IBM JVM can be <a href=\"https://web.archive.org/web/20151030183221/http://www.ibm.com/developerworks/java/library/j-ibmjava5/\">configured with launch parameters</a> to count or time method executions, but it’s only advisable to do this for a restricted subset of methods. An alternate method of collecting profiling information is to <em>sample</em> - that is, check periodically what method is executing. This is much less expensive but doesn’t give as much detail as tracing profilers. The Health Center uses method sampling already built into the JVM to allow profiling with extremely low overhead.</p>\n<p>Often it will be obvious when inspecting a hot method if it’s being called frequently or is slow to run. Code with loops, particularly nested loops, is probably expensive to run. Code which doesn’t seem to do much but which is at the top of a profile is probably being called a lot. This leads neatly to the next steps in optimization: eliminate loops and do less work inside loops for expensive methods, and call inexpensive method less frequently.</p>\n<p>How do you go about making sure a method is called less? Method profilers which also record stack traces can make calling method less pretty easy. For example, this is the output of the Health Center, showing where calls to one of the top methods in the profile have come from:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6e9856dd914caab52018526fb45fbddf/e17e5/healthcenterinvocationpaths.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVQoz42R226DMBBE+f8PrFTK1QbCxRhIABsCnAi/NKpalYejWa28oxnZ+/j0+YoiojgkiAL8wCeMQ6cnMhNkhUTphlarX1FaobuWqinxVKcJs9qZJCImFTFJGnErcxpVM0534AD2fziY5hFvHAcexpDXikZVNG3tdLh37tF+PC9xmo7TA0/3mqzWxEIgZIKQKTIXdH2L7luMnTjYrhuele6zIS0qqqpwVcv65hKebPt6oe72XflMsT4tdjHY1WCXmWU1Lpmx82XO237o8GSRIfM/KN7UzRLhfv3H/o0XmbYWVYpNWOoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"healthcenterinvocationpaths\"\n        title=\"healthcenterinvocationpaths\"\n        src=\"/static/6e9856dd914caab52018526fb45fbddf/e17e5/healthcenterinvocationpaths.png\"\n        srcset=\"/static/6e9856dd914caab52018526fb45fbddf/772e8/healthcenterinvocationpaths.png 200w,\n/static/6e9856dd914caab52018526fb45fbddf/e17e5/healthcenterinvocationpaths.png 400w\"\n        sizes=\"(max-width: 400px) 100vw, 400px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>In this case, 98% of the time the <code class=\"language-text\">doSomeWork()</code> method was sampled, it was <code class=\"language-text\">animate()</code> that called it. 2% of the time, it was <code class=\"language-text\">draw()</code> that called it. In this case, the next step is to inspect the <code class=\"language-text\">animate()</code> method and see why it’s calling <code class=\"language-text\">doSomeWork()</code>. Often, at least in the first passes of optimisation, most of the calls to the top method are totally unnecessary and can be trivially eliminated.</p>","excerpt":"In a previous post, I described the general methodology I use to diagnose performance problems. Once an application has been identified as…","fields":{"title":"How to interpret a method profile","slug":"/how-interpre-method-profile/","prefix":"2009-05-12","shortDate":"05-12","category":"java","author":"holly cummins","displayCategory":"java","geography":null,"video":null,"slides":null,"oembeds":null,"cover":{"childImageSharp":{"resize":{"src":"/static/c3a3cc100b0382e408eadce36e40709e/630fb/healthcenterprofile.png"}}}},"frontmatter":{"type":"blog","event":null,"keynote":null,"code":null,"resources":null}},"authornote":{"id":"77e0dd69-1df1-59df-9a8e-f3f29c267627","html":"<p><strong>Holly Cummins</strong>. Holly Cummins is a Senior Principal Software Engineer at Red Hat, in the Quarkus Team. She is a\nkeynote speaker, author, and bad illustrator.</p>"}},"pageContext":{"slug":"/how-interpre-method-profile/","prev":{"id":"0952a9b4-5c39-5bc3-8058-35662f23f46a","fields":{"slug":"/how-do-you-solve-performance-problem/","prefix":"2009-05-11","draft":null,"source":"posts","category":"java"},"frontmatter":{"title":"How do you solve a performance problem?","url":null,"type":"blog"}},"next":{"id":"1eccba33-ba24-5f45-9aee-fd3c0b2b5fa0","fields":{"slug":"/health-center-released/","prefix":"2009-06-16","draft":null,"source":"posts","category":"java"},"frontmatter":{"title":"Health Center 1.0 released","url":null,"type":"blog"}},"source":"posts"}},"staticQueryHashes":["1862184931","421231837","835725211"]}